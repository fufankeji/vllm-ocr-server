#!/usr/bin/env python3
"""
Simple OCR Analysis Server
FastAPI server that uses minerU.py script for PDF processing
"""

import os
import sys
import subprocess
import asyncio
import logging
from pathlib import Path
from typing import Dict, Any

try:
    from fastapi import FastAPI, File, UploadFile, HTTPException, BackgroundTasks
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.staticfiles import StaticFiles
    from fastapi.responses import FileResponse, JSONResponse
    from pydantic import BaseModel
except ImportError:
    print("âŒ FastAPI not installed. Install with: pip install fastapi uvicorn python-multipart")
    sys.exit(1)

# Add app directory to path
sys.path.append(str(Path(__file__).parent / "app"))

from app.services.markdown_parser import MarkdownParser
from app.utils.file_utils import ensure_directories, cleanup_file
from app.models.ocr_models import OCRResponse, OCRResults

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Ensure directories exist
ensure_directories()

# Initialize FastAPI app
app = FastAPI(
    title="OCR Analysis Backend (Simple)",
    description="Backend service for PDF OCR processing using MinerU script",
    version="1.0.0"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")
app.mount("/exports", StaticFiles(directory="exports"), name="exports")

# Initialize services
markdown_parser = MarkdownParser()

class MinerUScriptService:
    """Service that uses minerU.py script for PDF processing"""

    def __init__(self):
        self.mineru_script = Path(__file__).parent.parent / "minerU.py"
        self.timeout = int(os.getenv("OCR_TIMEOUT", 300))  # 5 minutes default

    async def parse_pdf(self, pdf_path: str) -> Dict[str, Any]:
        """
        Parse PDF using minerU.py script

        Args:
            pdf_path: Path to the PDF file

        Returns:
            Dictionary with parsing results
        """
        try:
            logger.info(f"[MinerU Script] Starting to parse PDF: {Path(pdf_path).name}")

            if not self.mineru_script.exists():
                return {
                    "success": False,
                    "error": f"MinerU script not found: {self.mineru_script}"
                }

            # Run minerU.py script to get markdown
            cmd = [
                "python3",
                str(self.mineru_script)
            ]

            # Set environment variables
            env = os.environ.copy()
            env["PYTHONPATH"] = str(self.mineru_script.parent)

            try:
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=self.timeout,
                    cwd=self.mineru_script.parent,
                    env=env
                )

                if result.returncode != 0:
                    return {
                        "success": False,
                        "error": f"MinerU script failed: {result.stderr}"
                    }

                # Look for generated markdown file
                pdf_file = Path(pdf_path)
                temp_dir = Path(os.getenv("TEMP_DIR", "./temp"))
                markdown_file = temp_dir / f"{pdf_file.stem}_parsed.md"

                # If not found in temp dir, check script output directory
                if not markdown_file.exists():
                    markdown_file = self.mineru_script.parent / f"{pdf_file.stem}_parsed.md"

                if markdown_file.exists():
                    content = markdown_file.read_text(encoding='utf-8')

                    logger.info(f"[MinerU Script] Successfully parsed PDF: {pdf_file.name}")
                    logger.info(f"   Markdown file: {markdown_file}")
                    logger.info(f"   Content length: {len(content)} characters")

                    return {
                        "success": True,
                        "content": content,
                        "markdown_file": str(markdown_file),
                        "metadata": {
                            "script_used": str(self.mineru_script),
                            "return_code": result.returncode
                        }
                    }
                else:
                    return {
                        "success": False,
                        "error": "No markdown file generated by MinerU script"
                    }

            except subprocess.TimeoutExpired:
                return {
                    "success": False,
                    "error": f"MinerU script timed out after {self.timeout} seconds"
                }
            except Exception as e:
                return {
                    "success": False,
                    "error": f"Failed to run MinerU script: {str(e)}"
                }

        except Exception as e:
            logger.error(f"[MinerU Script] Failed to parse PDF: {str(e)}")
            return {
                "success": False,
                "error": f"MinerU Script parsing failed: {str(e)}"
            }

# Initialize MinerU script service
mineru_service = MinerUScriptService()

@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "message": "OCR Analysis Backend (Simple Version)",
        "version": "1.0.0",
        "status": "running",
        "note": "Uses minerU.py script for PDF processing"
    }

@app.get("/health")
async def health_check():
    """Health check endpoint"""

    # Check if minerU.py script exists
    mineru_available = mineru_service.mineru_script.exists()

    return {
        "status": "healthy" if mineru_available else "degraded",
        "timestamp": str(Path().absolute()),
        "services": {
            "mineru_script": {
                "available": mineru_available,
                "path": str(mineru_service.mineru_script)
            },
            "markdown_parser": {
                "available": True,
                "status": "working"
            }
        }
    }

@app.post("/api/ocr/analyze")
async def analyze_pdf(
    background_tasks: BackgroundTasks,
    file: UploadFile = File(...),
    model: str = "mineru",
    options: str = "{}"
):
    """
    Analyze PDF file using MinerU script
    """

    if model != "mineru":
        raise HTTPException(
            status_code=400,
            detail=f"Model '{model}' not supported. Currently only 'mineru' is available."
        )

    # Validate file type
    if file.content_type != "application/pdf":
        raise HTTPException(
            status_code=400,
            detail=f"File type '{file.content_type}' not supported. Only PDF files are allowed."
        )

    # Validate file size
    max_size = int(os.getenv("MAX_FILE_SIZE", 10485760))  # 10MB default
    content = await file.read()
    file_size = len(content)

    if file_size > max_size:
        raise HTTPException(
            status_code=413,
            detail=f"File size {file_size} exceeds maximum allowed size {max_size} bytes"
        )

    # Save uploaded file
    upload_dir = Path(os.getenv("UPLOAD_DIR", "./uploads"))
    file_path = upload_dir / file.filename

    try:
        with open(file_path, "wb") as f:
            f.write(content)

        logger.info(f"File uploaded: {file.filename} ({file_size} bytes)")

        # Process with MinerU script
        logger.info(f"Starting OCR analysis with {model}")

        # Parse PDF using MinerU script
        parse_result = await mineru_service.parse_pdf(str(file_path))

        if not parse_result.get("success"):
            raise HTTPException(
                status_code=500,
                detail=f"MinerU parsing failed: {parse_result.get('error', 'Unknown error')}"
            )

        # Parse markdown content
        markdown_file = parse_result.get("markdown_file")
        if not markdown_file or not Path(markdown_file).exists():
            raise HTTPException(
                status_code=500,
                detail="No markdown file generated by MinerU"
            )

        # Extract structured content from markdown
        structured_content = markdown_parser.parse(markdown_file)

        # Schedule cleanup
        background_tasks.add_task(cleanup_file, file_path)
        background_tasks.add_task(cleanup_file, markdown_file)

        logger.info(f"OCR analysis completed for {file.filename}")

        return OCRResponse(
            success=True,
            model=model,
            filename=file.filename,
            results=structured_content,
            metadata=parse_result.get("metadata", {})
        )

    except Exception as e:
        logger.error(f"Error processing file {file.filename}: {str(e)}")
        # Cleanup on error
        if file_path.exists():
            background_tasks.add_task(cleanup_file, file_path)
        raise HTTPException(
            status_code=500,
            detail=f"Processing failed: {str(e)}"
        )

@app.get("/exports/{filename}")
async def download_file(filename: str):
    """Download exported file"""
    file_path = Path("exports") / filename
    if not file_path.exists():
        raise HTTPException(
            status_code=404,
            detail="File not found"
        )

    return FileResponse(
        file_path,
        media_type='application/octet-stream',
        filename=filename
    )

if __name__ == "__main__":
    import uvicorn

    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", 8000))
    debug = os.getenv("DEBUG", "False").lower() == "true"

    logger.info(f"Starting OCR Analysis Backend (Simple) on {host}:{port}")
    logger.info(f"MinerU Script: {mineru_service.mineru_script}")
    logger.info(f"Environment: {debug}")

    uvicorn.run(
        "simple_server:app",
        host=host,
        port=port,
        reload=debug,
        log_level="info"
    )